이번 장에서는 먼저 벌칸(Vulkan)의 소개와 벌칸이 해결하고자 하는 문제점들에 대해 알아봅니다. 그 후, 첫 번째 삼각형을 그리는 데 필요한 요소들을 살펴볼 것입니다. 이를 통해 앞으로 이어질 각 장의 내용을 전체적인 그림 안에서 파악할 수 있게 될 것입니다. 마지막으로 벌칸 API의 구조와 일반적인 사용 패턴을 다루며 마무리하겠습니다.

## 벌칸의 기원

이전의 그래픽 API들과 마찬가지로, 벌칸은 [GPU](https://en.wikipedia.org/wiki/Graphics_processing_unit)에 대한 크로스플랫폼 추상화로 설계되었습니다. 이러한 기존 API 대부분의 문제점은, 이들이 설계될 당시의 그래픽 하드웨어가 대부분 설정 가능한 고정 기능(fixed functionality)에 제한되어 있었다는 것입니다. 프로그래머들은 정점(vertex) 데이터를 표준 형식으로 제공해야 했고, 조명이나 셰이딩 옵션에 대해서는 GPU 제조사의 재량에 맡겨야 했습니다.

그래픽 카드 아키텍처가 발전함에 따라, 프로그래밍 가능한 기능들이 점점 더 많이 제공되기 시작했습니다. 이 모든 새로운 기능들은 어떻게든 기존 API와 통합되어야 했습니다. 그 결과 이상적이지 않은 추상화가 생겨났고, 그래픽 드라이버는 프로그래머의 의도를 현대 그래픽 아키텍처에 매핑하기 위해 많은 추측을 해야 했습니다. 이것이 바로 게임 성능을 향상시키기 위한 드라이버 업데이트가, 때로는 상당한 폭으로, 빈번하게 이루어지는 이유입니다. 이러한 드라이버의 복잡성 때문에, 애플리케이션 개발자들은 [셰이더](https://en.wikipedia.org/wiki/Shader)에 허용되는 문법과 같이 제조사 간의 불일치 문제도 다루어야 합니다. 이러한 새로운 기능 외에도, 지난 10년간 강력한 그래픽 하드웨어를 갖춘 모바일 기기들이 대거 등장했습니다. 이 모바일 GPU들은 에너지 및 공간 요구사항에 따라 다른 아키텍처를 가집니다. 한 예로 [타일 기반 렌더링(tiled rendering)](https://en.wikipedia.org/wiki/Tiled_rendering)이 있는데, 이는 프로그래머에게 해당 기능에 대한 더 많은 제어권을 제공함으로써 성능을 향상시킬 수 있습니다. 이러한 API들의 시대에서 비롯된 또 다른 한계는 제한적인 멀티스레딩 지원으로, 이는 CPU 측의 병목 현상을 유발할 수 있습니다.

벌칸은 현대 그래픽 아키텍처를 위해 처음부터 새롭게 설계됨으로써 이러한 문제들을 해결합니다. 벌칸은 프로그래머가 더 상세한(verbose) API를 사용하여 자신의 의도를 명확하게 지정할 수 있게 함으로써 드라이버 오버헤드를 줄이고, 여러 스레드가 병렬로 커맨드를 생성하고 제출할 수 있도록 합니다. 또한 단일 컴파일러를 사용하는 표준화된 바이트코드 형식으로 전환하여 셰이더 컴파일의 불일치를 줄입니다. 마지막으로, 현대 그래픽 카드의 범용 처리 능력을 인정하여 그래픽과 컴퓨팅 기능을 단일 API로 통합합니다.

## 삼각형 하나를 그리기까지

이제 잘 만들어진 벌칸 프로그램에서 삼각형 하나를 렌더링하는 데 필요한 모든 단계를 개괄적으로 살펴보겠습니다. 여기서 소개되는 모든 개념은 다음 장들에서 자세히 설명될 것입니다. 이 부분은 개별 구성 요소들을 전체적인 그림 속에서 파악할 수 있도록 돕기 위함입니다.

### 1단계 - 인스턴스와 물리 장치 선택

벌칸 애플리케이션은 `VkInstance`를 통해 벌칸 API를 설정하는 것으로 시작합니다. 인스턴스는 애플리케이션과 사용하려는 API 확장에 대한 정보를 기술하여 생성합니다. 인스턴스를 생성한 후, 벌칸을 지원하는 하드웨어를 쿼리하고 연산에 사용할 하나 이상의 `VkPhysicalDevice`를 선택할 수 있습니다. VRAM 크기나 장치 기능과 같은 속성을 쿼리하여 원하는 장치를 선택할 수 있으며, 예를 들어 전용 그래픽 카드를 선호하도록 설정할 수 있습니다.

### 2단계 - 논리 장치와 큐 패밀리

사용할 하드웨어 장치를 선택한 후에는 `VkDevice`(논리 장치)를 생성해야 합니다. 여기서는 멀티 뷰포트 렌더링이나 64비트 부동소수점 같은, 사용할 `VkPhysicalDeviceFeatures`를 더 구체적으로 기술합니다. 또한 사용하고자 하는 큐 패밀리도 지정해야 합니다. 그리기 커맨드나 메모리 연산과 같이 벌칸으로 수행되는 대부분의 작업은 `VkQueue`에 제출되어 비동기적으로 실행됩니다. 큐는 큐 패밀리로부터 할당되며, 각 큐 패밀리는 자신의 큐에서 특정 유형의 작업 집합을 지원합니다. 예를 들어, 그래픽, 컴퓨트, 메모리 전송 작업을 위한 별도의 큐 패밀리가 있을 수 있습니다. 큐 패밀리의 가용성은 물리 장치를 선택하는 구별 요소로 사용될 수도 있습니다. 벌칸을 지원하는 장치가 그래픽 기능을 전혀 제공하지 않을 수도 있지만, 오늘날 벌칸을 지원하는 모든 그래픽 카드는 일반적으로 우리가 관심 있는 모든 큐 작업을 지원합니다.

### 3단계 - 윈도우 서피스와 스왑 체인

오프스크린 렌더링에만 관심 있는 것이 아니라면, 렌더링된 이미지를 표시할 윈도우를 생성해야 합니다. 윈도우는 네이티브 플랫폼 API나 [GLFW](http://www.glfw.org/), [SDL](https://www.libsdl.org/)과 같은 라이브러리를 사용하여 생성할 수 있습니다. 이 튜토리얼에서는 GLFW를 사용할 것이며, 이에 대한 자세한 내용은 다음 장에서 다룹니다.

윈도우에 실제로 렌더링하려면 두 가지 구성 요소가 더 필요합니다: 윈도우 서피스(`VkSurfaceKHR`)와 스왑 체인(`VkSwapchainKHR`)입니다. `KHR` 접미사에 주목하세요. 이는 이 객체들이 벌칸 확장의 일부임을 의미합니다. 벌칸 API 자체는 완전히 플랫폼에 독립적이므로, 윈도우 관리자와 상호작용하기 위해 표준화된 WSI(Window System Interface) 확장을 사용해야 합니다. 서피스는 렌더링 대상이 되는 윈도우에 대한 크로스플랫폼 추상화이며, 일반적으로 Windows의 `HWND`와 같은 네이티브 윈도우 핸들에 대한 참조를 제공하여 인스턴스화됩니다. 다행히도 GLFW 라이브러리에는 이러한 플랫폼별 세부 사항을 처리하는 내장 함수가 있습니다.

스왑 체인은 렌더 타겟의 모음입니다. 스왑 체인의 기본 목적은 현재 렌더링 중인 이미지와 화면에 표시 중인 이미지가 서로 다르도록 보장하는 것입니다. 이는 완전한 이미지만 표시되도록 하는 데 중요합니다. 프레임을 그릴 때마다 스왑 체인에 렌더링할 이미지를 요청해야 합니다. 프레임 그리기가 끝나면, 이미지는 언젠가 화면에 표시될 수 있도록 스왑 체인에 반환됩니다. 렌더 타겟의 수와 완성된 이미지를 화면에 표시하는 조건은 제시 모드(present mode)에 따라 달라집니다. 일반적인 제시 모드로는 이중 버퍼링(vsync)과 삼중 버퍼링이 있습니다. 이는 스왑 체인 생성 장에서 살펴보겠습니다.

일부 플랫폼에서는 `VK_KHR_display` 및 `VK_KHR_display_swapchain` 확장을 통해 윈도우 관리자와 상호작용 없이 디스플레이에 직접 렌더링할 수 있습니다. 이를 통해 전체 화면을 나타내는 서피스를 생성할 수 있으며, 예를 들어 자신만의 윈도우 관리자를 구현하는 데 사용될 수 있습니다.

### 4단계 - 이미지 뷰와 프레임버퍼

스왑 체인에서 얻은 이미지에 그리려면, 이를 `VkImageView`와 `VkFramebuffer`로 감싸야 합니다. 이미지 뷰는 사용할 이미지의 특정 부분을 참조하고, 프레임버퍼는 색상, 깊이, 스텐실 타겟으로 사용될 이미지 뷰들을 참조합니다. 스왑 체인에는 여러 개의 다른 이미지가 있을 수 있으므로, 각 이미지에 대해 이미지 뷰와 프레임버퍼를 미리 생성해두고 그리기 시점에 올바른 것을 선택할 것입니다.

### 5단계 - 렌더 패스

벌칸의 렌더 패스는 렌더링 작업 중에 사용되는 이미지의 유형, 사용 방식, 그리고 내용 처리 방법을 기술합니다. 우리의 초기 삼각형 렌더링 애플리케이션에서는, 단일 이미지를 색상 타겟으로 사용할 것이며, 그리기 작업 직전에 단색으로 지워지기를 원한다고 벌칸에 알릴 것입니다. 렌더 패스가 이미지의 유형만 기술하는 반면, `VkFramebuffer`는 실제로 특정 이미지를 이 슬롯에 바인딩합니다.

### 6단계 - 그래픽 파이프라인

벌칸의 그래픽 파이프라인은 `VkPipeline` 객체를 생성하여 설정합니다. 이는 뷰포트 크기 및 깊이 버퍼 연산과 같은 그래픽 카드의 설정 가능한 상태와 `VkShaderModule` 객체를 사용한 프로그래밍 가능한 상태를 기술합니다. `VkShaderModule` 객체는 셰이더 바이트코드로부터 생성됩니다. 드라이버는 또한 파이프라인에서 어떤 렌더 타겟이 사용될지 알아야 하며, 이는 렌더 패스를 참조하여 지정합니다.

기존 API와 비교하여 벌칸의 가장 독특한 특징 중 하나는, 그래픽 파이프라인의 거의 모든 구성이 사전에 설정되어야 한다는 것입니다. 즉, 다른 셰이더로 전환하거나 정점 레이아웃을 약간 변경하려면 그래픽 파이프라인 전체를 다시 생성해야 합니다. 이는 렌더링 작업에 필요한 모든 다양한 조합에 대해 미리 많은 `VkPipeline` 객체를 생성해야 함을 의미합니다. 뷰포트 크기나 클리어 색상과 같은 일부 기본 구성만 동적으로 변경할 수 있습니다. 또한 모든 상태는 명시적으로 기술되어야 합니다. 예를 들어, 기본 색상 혼합 상태 같은 것은 없습니다.

좋은 소식은, 적시 컴파일(just-in-time compilation) 방식보다는 사전 컴파일(ahead-of-time compilation) 방식에 가깝게 작업하기 때문에, 드라이버에 더 많은 최적화 기회가 있고 런타임 성능이 더 예측 가능하다는 것입니다. 왜냐하면 다른 그래픽 파이프라인으로 전환하는 것과 같은 큰 상태 변경이 매우 명시적으로 이루어지기 때문입니다.

### 7단계 - 커맨드 풀과 커맨드 버퍼

앞서 언급했듯이, 우리가 실행하고자 하는 벌칸의 많은 작업(예: 그리기 작업)은 큐에 제출되어야 합니다. 이러한 작업들은 제출되기 전에 먼저 `VkCommandBuffer`에 기록되어야 합니다. 이 커맨드 버퍼들은 특정 큐 패밀리와 연관된 `VkCommandPool`로부터 할당됩니다. 간단한 삼각형을 그리려면 다음과 같은 작업들을 포함하는 커맨드 버퍼를 기록해야 합니다:

*   렌더 패스 시작
*   그래픽 파이프라인 바인딩
*   정점 3개 그리기
*   렌더 패스 종료

프레임버퍼의 이미지는 스왑 체인이 어떤 특정 이미지를 제공하느냐에 따라 달라지기 때문에, 우리는 가능한 각 이미지에 대해 커맨드 버퍼를 기록하고 그리기 시점에 올바른 것을 선택해야 합니다. 대안은 매 프레임마다 커맨드 버퍼를 다시 기록하는 것인데, 이는 그다지 효율적이지 않습니다.

### 8단계 - 메인 루프

이제 그리기 커맨드들이 커맨드 버퍼에 감싸졌으므로, 메인 루프는 매우 간단합니다. 먼저 `vkAcquireNextImageKHR`로 스왑 체인에서 이미지를 얻습니다. 그런 다음 해당 이미지에 적합한 커맨드 버퍼를 선택하고 `vkQueueSubmit`으로 실행합니다. 마지막으로, `vkQueuePresentKHR`을 사용하여 화면에 표시하기 위해 이미지를 스왑 체인으로 반환합니다.

큐에 제출된 작업들은 비동기적으로 실행됩니다. 따라서 올바른 실행 순서를 보장하기 위해 세마포어(semaphore)와 같은 동기화 객체를 사용해야 합니다. 그리기 커맨드 버퍼의 실행은 이미지 획득이 완료되기를 기다리도록 설정되어야 합니다. 그렇지 않으면 화면에 표시되기 위해 아직 읽고 있는 이미지에 렌더링을 시작할 수 있습니다. `vkQueuePresentKHR` 호출은 다시 렌더링이 완료되기를 기다려야 하며, 이를 위해 렌더링이 완료된 후 신호를 보내는 두 번째 세마포어를 사용할 것입니다.

### 요약

이 간략한 여정은 첫 번째 삼각형을 그리기 위해 앞으로 해야 할 일에 대한 기본적인 이해를 제공했을 것입니다. 실제 프로그램에는 정점 버퍼 할당, 유니폼 버퍼 생성, 텍스처 이미지 업로드와 같은 더 많은 단계가 포함되며, 이는 후속 장에서 다룰 것입니다. 하지만 벌칸은 그 자체로 학습 곡선이 가파르기 때문에 간단하게 시작하겠습니다. 참고로, 처음에는 정점 버퍼를 사용하는 대신 정점 좌표를 정점 셰이더에 내장하여 약간의 편법을 사용할 것입니다. 이는 정점 버퍼 관리가 먼저 커맨드 버퍼에 대한 어느 정도의 익숙함을 요구하기 때문입니다.

요약하자면, 첫 번째 삼각형을 그리기 위해 우리는 다음을 수행해야 합니다:

*   `VkInstance` 생성
*   지원되는 그래픽 카드(`VkPhysicalDevice`) 선택
*   그리기와 화면 표시를 위한 `VkDevice`와 `VkQueue` 생성
*   윈도우, 윈도우 서피스, 스왑 체인 생성
*   스왑 체인 이미지들을 `VkImageView`로 감싸기
*   렌더 타겟과 사용법을 명시하는 렌더 패스 생성
*   렌더 패스를 위한 프레임버퍼 생성
*   그래픽 파이프라인 설정
*   가능한 모든 스왑 체인 이미지에 대해 그리기 커맨드가 담긴 커맨드 버퍼를 할당하고 기록
*   이미지를 획득하고, 올바른 그리기 커맨드 버퍼를 제출하고, 이미지를 다시 스왑 체인으로 반환하여 프레임 그리기

단계가 많지만, 각 개별 단계의 목적은 앞으로의 장들에서 매우 간단하고 명확하게 설명될 것입니다. 만약 단일 단계가 전체 프로그램과 어떻게 관련되는지 혼란스럽다면, 이 장을 다시 참조해야 합니다.

## API 개념

이 장은 벌칸 API가 더 낮은 수준에서 어떻게 구조화되어 있는지에 대한 간략한 개요로 마무리하겠습니다.

### 코딩 규칙

모든 벌칸 함수, 열거형, 구조체는 LunarG에서 개발한 [벌칸 SDK](https://lunarg.com/vulkan-sdk/)에 포함된 `vulkan.h` 헤더에 정의되어 있습니다. 이 SDK를 설치하는 방법은 다음 장에서 살펴보겠습니다.

함수는 소문자 `vk` 접두사를, 열거형과 구조체 같은 타입은 `Vk` 접두사를, 열거형 값은 `VK_` 접두사를 가집니다. API는 함수에 매개변수를 제공하기 위해 구조체를 많이 사용합니다. 예를 들어, 객체 생성은 일반적으로 다음 패턴을 따릅니다:

```c++
VkXXXCreateInfo createInfo{};
createInfo.sType = VK_STRUCTURE_TYPE_XXX_CREATE_INFO;
createInfo.pNext = nullptr;
createInfo.foo = ...;
createInfo.bar = ...;

VkXXX object;
if (vkCreateXXX(&createInfo, nullptr, &object) != VK_SUCCESS) {
    std::cerr << "객체 생성 실패" << std::endl;
    return false;
}
```

벌칸의 많은 구조체는 `sType` 멤버에 구조체의 타입을 명시적으로 지정하도록 요구합니다. `pNext` 멤버는 확장 구조체를 가리킬 수 있으며, 이 튜토리얼에서는 항상 `nullptr`일 것입니다. 객체를 생성하거나 파괴하는 함수는 `VkAllocationCallbacks` 매개변수를 가지며, 이를 통해 드라이버 메모리를 위한 커스텀 할당자를 사용할 수 있습니다. 이 또한 이 튜토리얼에서는 `nullptr`로 남겨둘 것입니다.

거의 모든 함수는 `VK_SUCCESS` 또는 오류 코드를 나타내는 `VkResult`를 반환합니다. 명세서는 각 함수가 어떤 오류 코드를 반환할 수 있는지와 그 의미를 설명합니다.

### 유효성 검사 레이어

앞서 언급했듯이, 벌칸은 고성능과 낮은 드라이버 오버헤드를 위해 설계되었습니다. 따라서 기본적으로 매우 제한적인 오류 검사 및 디버깅 기능만 포함합니다. 잘못된 작업을 수행하면 드라이버가 오류 코드를 반환하는 대신 충돌하는 경우가 많으며, 더 나쁜 경우, 여러분의 그래픽 카드에서는 작동하는 것처럼 보이다가 다른 그래픽 카드에서는 완전히 실패할 수 있습니다.

벌칸은 *유효성 검사 레이어(validation layers)*라는 기능을 통해 광범위한 검사를 활성화할 수 있습니다. 유효성 검사 레이어는 API와 그래픽 드라이버 사이에 삽입될 수 있는 코드 조각으로, 함수 매개변수에 대한 추가 검사 실행이나 메모리 관리 문제 추적과 같은 작업을 수행합니다. 좋은 점은 개발 중에는 이를 활성화했다가 애플리케이션을 출시할 때는 완전히 비활성화하여 오버헤드가 전혀 없게 할 수 있다는 것입니다. 누구나 자신만의 유효성 검사 레이어를 작성할 수 있지만, 이 튜토리얼에서는 LunarG의 벌칸 SDK가 제공하는 표준 유효성 검사 레이어 세트를 사용할 것입니다. 또한 레이어로부터 디버그 메시지를 받기 위해 콜백 함수를 등록해야 합니다.

벌칸은 모든 작업에 대해 매우 명시적이고 유효성 검사 레이어는 매우 광범위하기 때문에, 화면이 왜 검은색으로 나오는지 알아내는 것이 OpenGL이나 Direct3D에 비해 훨씬 쉬울 수 있습니다.

코드를 작성하기 전까지 이제 단 한 단계만 남았습니다. 바로 [개발 환경 설정하기](!en/Development_environment)입니다.