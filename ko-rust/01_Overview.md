이번 장에서는 먼저 벌칸(Vulkan)의 소개와 벌칸이 해결하고자 하는 문제점들에 대해 알아봅니다. 그 후, Rust와 **`ash`** 라이브러리를 사용하여 첫 번째 삼각형을 그리는 데 필요한 요소들을 살펴볼 것입니다. 이를 통해 앞으로 이어질 각 장의 내용을 전체적인 그림 안에서 파악할 수 있게 될 것입니다. 마지막으로 벌칸 API의 구조와 `ash`를 사용한 일반적인 코딩 패턴을 다루며 마무리하겠습니다.

## 벌칸의 기원

이전의 그래픽 API들과 마찬가지로, 벌칸은 [GPU](https.en.wikipedia.org/wiki/Graphics_processing_unit)에 대한 크로스플랫폼 추상화로 설계되었습니다. 이러한 기존 API 대부분의 문제점은, 이들이 설계될 당시의 그래픽 하드웨어가 대부분 설정 가능한 고정 기능(fixed functionality)에 제한되어 있었다는 것입니다. 프로그래머들은 정점(vertex) 데이터를 표준 형식으로 제공해야 했고, 조명이나 셰이딩 옵션에 대해서는 GPU 제조사의 재량에 맡겨야 했습니다.

그래픽 카드 아키텍처가 발전함에 따라, 프로그래밍 가능한 기능들이 점점 더 많이 제공되기 시작했습니다. 이 모든 새로운 기능들은 어떻게든 기존 API와 통합되어야 했습니다. 그 결과 이상적이지 않은 추상화가 생겨났고, 그래픽 드라이버는 프로그래머의 의도를 현대 그래픽 아키텍처에 매핑하기 위해 많은 추측을 해야 했습니다. 이것이 바로 게임 성능을 향상시키기 위한 드라이버 업데이트가, 때로는 상당한 폭으로, 빈번하게 이루어지는 이유입니다. 이러한 드라이버의 복잡성 때문에, 애플리케이션 개발자들은 [셰이더](https.en.wikipedia.org/wiki/Shader)에 허용되는 문법과 같이 제조사 간의 불일치 문제도 다루어야 합니다. 이러한 새로운 기능 외에도, 지난 10년간 강력한 그래픽 하드웨어를 갖춘 모바일 기기들이 대거 등장했습니다. 이 모바일 GPU들은 에너지 및 공간 요구사항에 따라 다른 아키텍처를 가집니다. 한 예로 [타일 기반 렌더링(tiled rendering)](https.en.wikipedia.org/wiki/Tiled_rendering)이 있는데, 이는 프로그래머에게 해당 기능에 대한 더 많은 제어권을 제공함으로써 성능을 향상시킬 수 있습니다. 이러한 API들의 시대에서 비롯된 또 다른 한계는 제한적인 멀티스레딩 지원으로, 이는 CPU 측의 병목 현상을 유발할 수 있습니다.

벌칸은 현대 그래픽 아키텍처를 위해 처음부터 새롭게 설계됨으로써 이러한 문제들을 해결합니다. 벌칸은 프로그래머가 더 상세한(verbose) API를 사용하여 자신의 의도를 명확하게 지정할 수 있게 함으로써 드라이버 오버헤드를 줄이고, 여러 스레드가 병렬로 커맨드를 생성하고 제출할 수 있도록 합니다. 또한 단일 컴파일러를 사용하는 표준화된 바이트코드 형식으로 전환하여 셰이더 컴파일의 불일치를 줄입니다. 마지막으로, 현대 그래픽 카드의 범용 처리 능력을 인정하여 그래픽과 컴퓨팅 기능을 단일 API로 통합합니다.

## 삼각형 하나를 그리기까지 (Rust와 `ash` 버전)

이제 잘 만들어진 벌칸 프로그램에서 삼각형 하나를 렌더링하는 데 필요한 모든 단계를 `ash` 라이브러리 관점에서 개괄적으로 살펴보겠습니다. 여기서 소개되는 모든 개념은 다음 장들에서 자세히 설명될 것입니다.

### 1단계 - 엔트리, 인스턴스와 물리 장치 선택

Rust에서 `ash`를 사용한 벌칸 애플리케이션은 `ash::Entry`를 로드하는 것으로 시작합니다. 이는 벌칸 로더에 대한 진입점입니다. `Entry`를 통해 `ash::Instance`를 생성합니다. 인스턴스는 애플리케이션 정보와 사용할 API 확장을 기술하여 만듭니다. 인스턴스를 생성한 후, 벌칸을 지원하는 하드웨어(`vk::PhysicalDevice`)를 질의하고 연산에 사용할 하나 이상의 물리 장치를 선택할 수 있습니다. `instance.enumerate_physical_devices()`와 같은 메소드를 사용하여 장치 목록을 얻고, `instance.get_physical_device_properties()` 등으로 속성을 확인하여 원하는 장치를 선택합니다.

### 2단계 - 논리 장치와 큐 패밀리

사용할 하드웨어 장치를 선택한 후에는 `ash::Device`(논리 장치)를 생성해야 합니다. 여기서는 멀티 뷰포트 렌더링이나 64비트 부동소수점 같은, 사용할 기능(`vk::PhysicalDeviceFeatures`)을 더 구체적으로 기술합니다. 또한 사용하고자 하는 큐 패밀리도 지정해야 합니다. 벌칸의 대부분 작업은 `vk::Queue`에 제출되어 비동기적으로 실행됩니다. 큐는 특정 작업 유형(그래픽, 컴퓨트 등)을 지원하는 큐 패밀리로부터 할당받습니다. `ash::Device`는 `instance.create_device()` 메소드를 통해 생성되며, 이후 대부분의 벌칸 객체 생성과 커맨드 호출은 이 `Device` 객체를 통해 이루어집니다.

### 3단계 - 윈도우 서피스와 스왑 체인

오프스크린 렌더링이 아니라면 렌더링 결과를 표시할 윈도우가 필요합니다. Rust 생태계에서는 보통 `winit` 크레이트를 사용하여 윈도우를 생성합니다.

윈도우에 렌더링하려면 윈도우 서피스(`vk::SurfaceKHR`)와 스왑 체인(`vk::SwapchainKHR`)이 필요합니다. `KHR` 접미사는 이것이 벌칸 확장 기능임을 의미합니다. `ash`에서는 `ash::extensions::khr::Surface`와 `ash::extensions::khr::Swapchain` 같은 확장 로더를 통해 관련 함수를 사용합니다. 서피스는 `ash_window` 크레이트를 사용하면 `winit` 윈도우로부터 쉽게 생성할 수 있습니다.

스왑 체인은 화면에 표시될 이미지들의 집합입니다. 현재 렌더링 중인 이미지와 화면에 표시 중인 이미지를 분리하여, 찢어짐(tearing) 없이 완전한 이미지만 표시되도록 보장합니다. 매 프레임마다 스왑 체인에서 렌더링할 이미지를 받아오고, 렌더링이 끝나면 다시 스왑 체인에 반환하여 화면에 표시되도록 합니다.

### 4단계 - 이미지 뷰와 프레임버퍼

스왑 체인에서 얻은 이미지(`vk::Image`)에 그리려면, 이를 `vk::ImageView`와 `vk::Framebuffer`로 감싸야 합니다. 이미지 뷰는 이미지의 특정 부분을 어떻게 사용할지 정의하고, 프레임버퍼는 렌더링 시 색상, 깊이, 스텐실 버퍼로 사용될 이미지 뷰들을 참조합니다. `device.create_image_view()`와 `device.create_framebuffer()` 메소드를 사용해 생성하며, 스왑 체인의 각 이미지마다 프레임버퍼를 미리 만들어 둡니다.

### 5단계 - 렌더 패스

렌더 패스(`vk::RenderPass`)는 렌더링 작업 동안 사용될 첨부 파일(attachment)들의 형식과 사용 방법을 정의합니다. 예를 들어, "하나의 색상 첨부파일을 사용하며, 렌더링 시작 시 파란색으로 클리어한다"와 같이 설정합니다. `device.create_render_pass()`를 통해 생성합니다.

### 6단계 - 그래픽 파이ప్라인

그래픽 파이프라인(`vk::Pipeline`)은 뷰포트 크기, 깊이 테스트 설정 등 그래픽 카드의 설정 가능한 상태와 셰이더(`vk::ShaderModule`)를 포함한 프로그래밍 가능한 상태를 모두 캡슐화한 객체입니다. `ash`에서는 `device.create_graphics_pipelines()` 메소드로 생성합니다.

벌칸의 가장 큰 특징은 거의 모든 파이프라인 상태를 사전에 고정해야 한다는 점입니다. 셰이더를 바꾸거나 정점 데이터 형식을 조금이라도 변경하려면 파이프라인 객체 전체를 새로 만들어야 합니다. 따라서 애플리케이션에서 사용할 모든 상태 조합에 대해 미리 여러 파이프라인을 만들어두는 것이 일반적입니다. 이는 번거롭지만, 드라이버가 사전에 최적화를 수행할 수 있게 하여 런타임 성능을 더 예측 가능하게 만듭니다.

### 7단계 - 커맨드 풀과 커맨드 버퍼

그리기와 같은 벌칸 작업은 큐에 제출하기 전에 `vk::CommandBuffer`에 기록되어야 합니다. 커맨드 버퍼는 특정 큐 패밀리와 연결된 `vk::CommandPool`에서 할당받습니다. 삼각형을 그리기 위해 커맨드 버퍼에 기록할 내용은 다음과 같습니다.

*   `device.cmd_begin_render_pass()`
*   `device.cmd_bind_pipeline()`
*   `device.cmd_draw()`
*   `device.cmd_end_render_pass()`

스왑 체인의 각 이미지에 대해 별도의 커맨드 버퍼를 미리 기록해두고, 렌더링 시점에 해당 프레임의 이미지에 맞는 커맨드 버퍼를 선택하여 제출하는 것이 효율적입니다.

### 8단계 - 메인 루프 (이벤트 루프)

메인 루프는 비교적 간단합니다. `swapchain_loader.acquire_next_image_khr()`로 스왑 체인에서 렌더링할 이미지를 얻고, 해당 이미지의 인덱스에 맞는 커맨드 버퍼를 `device.queue_submit()`으로 큐에 제출합니다. 작업이 완료되면 `swapchain_loader.queue_present_khr()`로 이미지를 화면에 표시하도록 요청합니다.

이 모든 작업은 비동기이므로 세마포어(`vk::Semaphore`)와 펜스(`vk::Fence`) 같은 동기화 객체를 사용하여 실행 순서를 보장해야 합니다. 예를 들어, 이미지 획득이 끝나야 렌더링을 시작하고, 렌더링이 끝나야 화면에 표시하도록 순서를 제어해야 합니다.

### 요약

이 간략한 여정은 `ash`를 사용하여 첫 번째 삼각형을 그리기 위해 앞으로 해야 할 일에 대한 기본적인 이해를 제공했을 것입니다. 실제 프로그램에는 정점 버퍼 할당, 유니폼 버퍼 생성 등이 추가되지만, 일단은 간단한 구조부터 시작하겠습니다.

요약하자면, 첫 번째 삼각형을 그리기 위해 우리는 다음을 수행해야 합니다:

*   `ash::Entry` 로드 후 `ash::Instance` 생성
*   지원되는 `vk::PhysicalDevice` 선택
*   `ash::Device`와 `vk::Queue` 생성
*   `winit` 등으로 윈도우 생성 후 서피스와 스왑 체인 생성
*   스왑 체인 이미지들을 `vk::ImageView`로 감싸기
*   렌더 타겟과 사용법을 명시하는 `vk::RenderPass` 생성
*   렌더 패스를 위한 `vk::Framebuffer` 생성
*   `vk::Pipeline`(그래픽 파이프라인) 설정
*   각 스왑 체인 이미지에 대한 `vk::CommandBuffer`를 할당하고 그리기 커맨드 기록
*   메인 루프에서 이미지 획득, 커맨드 버퍼 제출, 화면 표시를 반복

## API 개념 (`ash` 중심)

이 장은 `ash` 라이브러리 관점에서 벌칸 API가 어떻게 구조화되어 있는지 간략히 살펴보며 마무리합니다.

### 코딩 규칙

벌칸의 모든 함수, 타입, 상수는 **`ash`** 크레이트를 통해 접근합니다.

*   함수는 `Entry`, `Instance`, `Device` 객체의 **메소드**로 호출됩니다. (예: `device.create_buffer(...)`)
*   타입은 `ash::vk` 모듈 아래에 있습니다. (예: `ash::vk::BufferCreateInfo`, `ash::vk::SubmitInfo`)
*   상수 역시 `ash::vk` 모듈 아래에 대문자로 정의됩니다. (예: `ash::vk::Result::SUCCESS`)

`ash`는 객체 생성 시 **빌더(builder) 패턴**을 광범위하게 사용합니다. 이는 C 스타일의 구조체 초기화보다 훨씬 안전하고 직관적입니다.

```rust
use ash::vk;

// 빌더 패턴을 사용하여 생성 정보 구조체 초기화
let create_info = vk::FenceCreateInfo::builder()
    .flags(vk::FenceCreateFlags::SIGNALED);
    // .s_type은 빌더가 자동으로 설정
    // .p_next는 .push_next() 메소드로 설정 가능

let fence = unsafe {
    device
        .create_fence(&create_info, None)
        .expect("펜스 생성 실패")
};
```

C API와 달리, `ash`의 빌더는 `sType` 필드를 자동으로 채워줍니다. `pNext`를 이용한 확장 구조체 체인은 `.push_next()` 메소드를 사용하여 타입 안전하게 연결할 수 있습니다. 대부분의 `ash` 함수는 `Result<T, vk::Result>`를 반환하므로, Rust의 `?` 연산자나 `match`를 사용한 에러 처리가 자연스럽습니다.

객체 소멸 또한 `device.destroy_fence(fence, None)`와 같이 명시적인 메소드 호출을 통해 이루어집니다. `ash` 핸들 자체는 `Drop`을 구현하지 않으므로, 자원 누수를 막기 위해 직접 해제 코드를 호출해야 합니다. (또는 `ash-rs` 커뮤니티의 래퍼 라이브러리를 사용할 수 있습니다.)

### 유효성 검사 레이어

벌칸은 낮은 오버헤드를 위해 기본적으로 오류 검사를 거의 하지 않습니다. 따라서 개발 중에는 **유효성 검사 레이어(validation layers)**를 활성화하는 것이 필수적입니다. 이 레이어들은 API와 드라이버 사이에서 파라미터 유효성 검사, 메모리 관리 추적 등 다양한 디버깅 정보를 제공합니다.

`ash`에서는 `Instance`를 생성할 때 활성화할 레이어의 이름을 문자열 슬라이스로 전달하여 간단히 활성화할 수 있습니다. 레이어가 보내는 디버그 메시지를 수신하기 위한 콜백 함수 또한 `Instance` 생성 시 등록합니다. 벌칸의 명시적인 API와 상세한 유효성 검사 레이어 덕분에, 문제가 발생했을 때 원인을 찾는 것이 OpenGL이나 Direct3D보다 오히려 쉬울 수 있습니다.

코드를 작성하기 전까지 이제 단 한 단계만 남았습니다. 바로 [개발 환경 설정하기](!en/Development_environment)입니다.